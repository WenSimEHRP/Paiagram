use crate::types::{
    ColorDegree, GraphLength, IntervalID, IntervalLength, IntervalLengthExt, Node, ScaleMode,
    StationID, Time, Track, TrainNumberID,
};
use crate::utils::string_to_u32;
use anyhow::{Context, Result, anyhow};
use multimap::MultiMap;
use serde::de::Deserializer;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::rc::Rc;

#[derive(Deserialize)]
pub struct NetworkInput {
    stations: HashMap<StationID, StationInput>,
    #[serde(deserialize_with = "deserialize_intervals")]
    intervals: HashMap<IntervalID, IntervalInput>,
    #[serde(deserialize_with = "deserialize_trains")]
    trains: HashMap<TrainNumberID, MultiMap<IntervalID, (Time, Time, Option<Track>)>>,
}

fn deserialize_intervals<'de, D>(
    deserializer: D,
) -> Result<HashMap<IntervalID, IntervalInput>, D::Error>
where
    D: Deserializer<'de>,
{
    let vec: Vec<(IntervalID, IntervalInput)> = Vec::deserialize(deserializer)?;
    Ok(vec.into_iter().collect())
}

fn deserialize_trains<'de, D>(
    deserializer: D,
) -> Result<HashMap<TrainNumberID, MultiMap<IntervalID, (Time, Time, Option<Track>)>>, D::Error>
where
    D: Deserializer<'de>,
{
    let map: HashMap<TrainNumberID, Vec<(IntervalID, (Time, Time, Option<Track>))>> =
        HashMap::deserialize(deserializer)?;
    Ok(map
        .into_iter()
        .map(|(train_id, intervals)| {
            let mut multimap = MultiMap::new();
            for (interval_id, time_data) in intervals {
                multimap.insert(interval_id, time_data);
            }
            (train_id, multimap)
        })
        .collect())
}

#[derive(Deserialize)]
pub struct NetworkConfig {
    mode: ScaleMode,
    scale: f32,
    unit_length: GraphLength,
    /// the intervals to draw, with a boolean indicating whether
    /// to draw the reverse interval
    intervals_to_draw: Vec<(IntervalID, bool)>,
    // the stations to draw is automatically determined
}

#[derive(Deserialize)]
pub struct StationInput {
    tracks: Option<Track>,
    label_size: Option<(f32, f32)>,
}

#[derive(Deserialize)]
pub struct IntervalInput {
    length: IntervalLength,
}

// 处理后的结构 - 包含计算字段
#[derive(Serialize)]
pub struct Network {
    stations: HashMap<StationID, Station>,
    intervals: HashMap<IntervalID, Interval>,
    trains: HashMap<TrainNumberID, Train>,
}

#[derive(Serialize)]
pub struct Station {
    tracks: Option<Track>,
    #[serde(skip)]
    label_size: Option<(f32, f32)>,
}

#[derive(Serialize)]
pub struct Interval {
    length: IntervalLength,
    draw_height: GraphLength,
    trains_per_10_minutes: [[usize; 6]; 24],
    #[serde(skip)]
    train_departures: HashSet<TrainNumberID>,
}

#[derive(Serialize)]
pub struct Train {
    #[serde(skip)]
    schedule: MultiMap<IntervalID, (Time, Time, Option<Track>)>,
    color: ColorDegree,
    nodes: Vec<Vec<Node>>,
}

impl Network {
    pub fn from_input_with_config(mut input: NetworkInput, config: &NetworkConfig) -> Result<Self> {
        let mut stations_to_draw: HashSet<StationID> =
            HashSet::with_capacity(config.intervals_to_draw.len() + 1);
        let mut intervals_to_draw: HashSet<IntervalID> =
            // reverse intervals are also taken into account
            HashSet::with_capacity(config.intervals_to_draw.len() * 2);
        for (id, draw_reverse) in config.intervals_to_draw.iter() {
            stations_to_draw.insert(id.0);
            stations_to_draw.insert(id.1);
            intervals_to_draw.insert(*id);
            if *draw_reverse {
                intervals_to_draw.insert((id.1, id.0));
            }
        }
        let stations: HashMap<StationID, Station> = stations_to_draw
            .into_iter()
            .map(|id| -> Result<(StationID, Station)> {
                let station = input
                    .stations
                    .remove(&id)
                    .ok_or_else(|| anyhow!("Missing station input for ID: {}", id))?;
                Ok((id, Station::from(station)))
            })
            .collect::<Result<HashMap<_, _>, _>>()
            .context("Failed to create stations")?;
        let intervals: HashMap<IntervalID, Interval> = intervals_to_draw
            .into_iter()
            .map(|id| -> Result<(IntervalID, Interval)> {
                let interval = input
                    .intervals
                    .remove(&id)
                    .ok_or_else(|| anyhow!("Missing interval input for ID: {:?}", id))?;
                Ok((
                    id,
                    Interval::from_input(interval, config.scale, config.mode, config.unit_length),
                ))
            })
            .collect::<Result<HashMap<_, _>, _>>()
            .context("Failed to create intervals")?;
        let mut network = Network {
            stations,
            intervals,
            trains: HashMap::with_capacity(input.trains.len()),
        };
        network
            .finalize_trains(input.trains)
            .context("Failed to finalize trains")?;
        Ok(network)
    }
    fn finalize_trains(
        &mut self,
        trains: HashMap<TrainNumberID, MultiMap<IntervalID, (Time, Time, Option<Track>)>>,
    ) -> Result<()> {
        for (train_id, intervals) in trains {
            let valid_interval_ids: Vec<_> = intervals
                .keys()
                .filter(|interval_id| self.intervals.contains_key(interval_id))
                .collect();

            if !valid_interval_ids.is_empty() {
                for interval_id in valid_interval_ids {
                    let interval = self.intervals.get_mut(interval_id).unwrap();
                    interval.train_departures.insert(train_id);
                }

                let train = Train {
                    schedule: intervals,
                    color: (train_id % 360) as ColorDegree,
                    nodes: Vec::new(),
                };
                self.trains.insert(train_id, train);
            }
        }
        Ok(())
    }
}

impl From<StationInput> for Station {
    fn from(input: StationInput) -> Self {
        Station {
            tracks: input.tracks,
            label_size: input.label_size,
        }
    }
}

impl Interval {
    pub fn from_input(
        input: IntervalInput,
        scale: f32,
        mode: ScaleMode,
        unit_length: GraphLength,
    ) -> Self {
        Interval {
            length: input.length,
            draw_height: input.length.to_graph_length(scale, mode, unit_length),
            trains_per_10_minutes: [[0; 6]; 24],
            train_departures: HashSet::new(),
        }
    }
}
